{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import * as typer from '@tinyhttp/content-type'\nimport mime from 'mime'\n\nfunction normalizeType(value: string) {\n  // parse the type\n  const type = typer.parse(value)\n  type.parameters = {}\n  // reformat it\n  return typer.format(type)\n}\n\nfunction tryNormalizeType(value: string) {\n  if (!value) return null\n\n  try {\n    return normalizeType(value)\n  } catch (err) {\n    return null\n  }\n}\n\nfunction mimeMatch(expected: string | boolean, actual: string | boolean): boolean {\n  // invalid type\n  if (expected === false) return false\n\n  // split types\n  const actualParts = (actual as string).split('/')\n  const expectedParts = (expected as string).split('/')\n\n  // invalid format\n  if (actualParts.length !== 2 || expectedParts.length !== 2) return false\n\n  // validate type\n  if (expectedParts[0] !== '*' && expectedParts[0] !== actualParts[0]) return false\n\n  // validate suffix wildcard\n  if (expectedParts[1].slice(0, 2) === '*+')\n    return (\n      expectedParts[1].length <= actualParts[1].length + 1 &&\n      expectedParts[1].slice(1) === actualParts[1].slice(1 - expectedParts[1].length)\n    )\n\n  // validate subtype\n  if (expectedParts[1] !== '*' && expectedParts[1] !== actualParts[1]) return false\n\n  return true\n}\n\nfunction normalize(type: string | unknown) {\n  // invalid type\n  if (typeof type !== 'string') return false\n\n  switch (type) {\n    case 'urlencoded':\n      return 'application/x-www-form-urlencoded'\n    case 'multipart':\n      return 'multipart/*'\n  }\n  // \"+json\" -> \"*/*+json\" expando\n  if (type[0] === '+') return '*/*' + type\n\n  return type.indexOf('/') === -1 ? mime.getType(type) : type\n}\n\n/**\n * Compare a `value` content-type with `types`.\n * Each `type` can be an extension like `html`,\n * a special shortcut like `multipart` or `urlencoded`,\n * or a mime type.\n */\nexport const typeIs = (value: string, ...types: string[]) => {\n  let i: number\n  // remove parameters and normalize\n  const val = tryNormalizeType(value)\n\n  // no type or invalid\n  if (!val) return false\n\n  // no types, return the content type\n  if (!types || !types.length) return val\n\n  let type: string\n  for (i = 0; i < types.length; i++) {\n    if (mimeMatch(normalize((type = types[i])), val)) {\n      return type[0] === '+' || type.indexOf('*') !== -1 ? val : type\n    }\n  }\n\n  // no matches\n  return false\n}\n"],"names":[],"mappings":";;AAGA,SAAS,cAAc,OAAe;AAE9B,QAAA,OAAO,MAAM,MAAM,KAAK;AAC9B,OAAK,aAAa;AAEX,SAAA,MAAM,OAAO,IAAI;AAC1B;AAEA,SAAS,iBAAiB,OAAe;AACvC,MAAI,CAAC;AAAc,WAAA;AAEf,MAAA;AACF,WAAO,cAAc,KAAK;AAAA,WACnB,KAAK;AACL,WAAA;AAAA,EACT;AACF;AAEA,SAAS,UAAU,UAA4B,QAAmC;AAEhF,MAAI,aAAa;AAAc,WAAA;AAGzB,QAAA,cAAe,OAAkB,MAAM,GAAG;AAC1C,QAAA,gBAAiB,SAAoB,MAAM,GAAG;AAGpD,MAAI,YAAY,WAAW,KAAK,cAAc,WAAW;AAAU,WAAA;AAG/D,MAAA,cAAc,CAAC,MAAM,OAAO,cAAc,CAAC,MAAM,YAAY,CAAC;AAAU,WAAA;AAG5E,MAAI,cAAc,CAAC,EAAE,MAAM,GAAG,CAAC,MAAM;AAEjC,WAAA,cAAc,CAAC,EAAE,UAAU,YAAY,CAAC,EAAE,SAAS,KACnD,cAAc,CAAC,EAAE,MAAM,CAAC,MAAM,YAAY,CAAC,EAAE,MAAM,IAAI,cAAc,CAAC,EAAE,MAAM;AAI9E,MAAA,cAAc,CAAC,MAAM,OAAO,cAAc,CAAC,MAAM,YAAY,CAAC;AAAU,WAAA;AAErE,SAAA;AACT;AAEA,SAAS,UAAU,MAAwB;AAEzC,MAAI,OAAO,SAAS;AAAiB,WAAA;AAErC,UAAQ,MAAM;AAAA,IACZ,KAAK;AACI,aAAA;AAAA,IACT,KAAK;AACI,aAAA;AAAA,EACX;AAEI,MAAA,KAAK,CAAC,MAAM;AAAK,WAAO,QAAQ;AAE7B,SAAA,KAAK,QAAQ,GAAG,MAAM,KAAK,KAAK,QAAQ,IAAI,IAAI;AACzD;AAQa,MAAA,SAAS,CAAC,UAAkB,UAAoB;AACvD,MAAA;AAEE,QAAA,MAAM,iBAAiB,KAAK;AAGlC,MAAI,CAAC;AAAY,WAAA;AAGb,MAAA,CAAC,SAAS,CAAC,MAAM;AAAe,WAAA;AAEhC,MAAA;AACJ,OAAK,IAAI,GAAG,IAAI,MAAM,QAAQ,KAAK;AAC7B,QAAA,UAAU,UAAW,OAAO,MAAM,CAAC,CAAE,GAAG,GAAG,GAAG;AACzC,aAAA,KAAK,CAAC,MAAM,OAAO,KAAK,QAAQ,GAAG,MAAM,KAAK,MAAM;AAAA,IAC7D;AAAA,EACF;AAGO,SAAA;AACT;"}