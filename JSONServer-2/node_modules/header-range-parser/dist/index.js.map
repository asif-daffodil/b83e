{
  "version": 3,
  "sources": ["../src/index.ts"],
  "sourcesContent": ["interface RangeWithIndex {\n  end: number;\n  index: number;\n  start: number;\n}\n\nexport interface Range {\n  end: number;\n  start: number;\n}\n\nexport interface Options {\n  /**\n   * @description The \"combine\" option can be set to `true`\n   * and overlapping & adjacent ranges\n   * will be combined into a single range.\n   */\n  combine?: boolean;\n  /**\n   * @description Throw or suppress errors.\n   */\n  throwError?: boolean;\n}\n\nexport type ResultUnsatisfiable = -1;\n\nexport type ResultInvalid = -2;\n\nexport type ResultWrongArgument = -3;\n\nexport type Result = ResultInvalid | ResultUnsatisfiable | ResultWrongArgument;\n\nexport const ERROR_INVALID_ARGUMENT: ResultWrongArgument = -3 as const;\n\nexport const ERROR_STRING_IS_NOT_HEADER: ResultInvalid = -2 as const;\n\nexport const ERROR_UNSATISFIABLE_RESULT: ResultUnsatisfiable = -1 as const;\n\n/**\n * @description Combine overlapping & adjacent ranges.\n * @param {Ranges} ranges\n * @returns {Ranges}\n */\nfunction combineRanges(ranges: Ranges): Ranges {\n  const ordered = ranges.map(mapWithIndex).sort(sortByRangeStart);\n  let order = 0;\n  for (let index = 1; index < ordered.length; index++) {\n    const range: RangeWithIndex = ordered[index];\n    const current: RangeWithIndex = ordered[order];\n    if (range.start > current.end + 1) {\n      ordered[++order] = range;\n    } else if (range.end > current.end) {\n      current.end = range.end;\n      current.index = Math.min(current.index, range.index);\n    }\n  }\n  ordered.length = order + 1;\n  const combined = [...ordered].sort(sortByRangeIndex).map(mapWithoutIndex) as Ranges;\n  combined.type = ranges.type;\n  return combined;\n}\n\n/**\n * @description Map function to add index value to ranges.\n * @param {RangeWithIndex} range\n * @param {number} index\n * @returns {RangeWithIndex}\n */\nfunction mapWithIndex(range: Range | RangeWithIndex, index: number): RangeWithIndex {\n  return { end: range.end, index, start: range.start };\n}\n\n/**\n * @description Map function to remove index value from ranges.\n * @param {RangeWithIndex} range\n * @returns {Range}\n */\nfunction mapWithoutIndex(range: RangeWithIndex): Range {\n  return { end: range.end, start: range.start };\n}\n\n/**\n * @description Sort function to sort ranges by index.\n * @param {RangeWithIndex} alpha\n * @param {RangeWithIndex} beta\n * @returns {number}\n */\nfunction sortByRangeIndex(alpha: RangeWithIndex, beta: RangeWithIndex): number {\n  return alpha.index - beta.index;\n}\n\n/**\n * @description Sort function to sort ranges by start position.\n * @param {Range} alpha\n * @param {Range} beta\n * @returns {number}\n */\nfunction sortByRangeStart(alpha: Range, beta: Range): number {\n  return alpha.start - beta.start;\n}\n\nexport class Ranges extends Array<Range> {\n  /**\n   * @description Header name or type\n   */\n  public type = \"\";\n  /**\n   * @description Return plain JavaScript array with 'type' property\n   * @returns {Array<Range>}\n   */\n  public toArray(): Array<Range> {\n    const array = Array.from(this) as Ranges;\n    array.type = this.type;\n    return array;\n  }\n}\n\nfunction csvToRanges(csv: string[], size: number): Ranges {\n  const ranges = new Ranges();\n  for (const item of csv) {\n    const range = item.split(\"-\");\n    let start = Number.parseInt(range[0], 10);\n    let end = Number.parseInt(range[1], 10);\n    if (Number.isNaN(start)) {\n      start = size - end;\n      end = size - 1;\n    } else if (Number.isNaN(end)) {\n      end = size - 1;\n    }\n    if (end > size - 1) {\n      end = size - 1;\n    }\n    if (Number.isNaN(start) || Number.isNaN(end) || start > end || start < 0) {\n      continue;\n    }\n    ranges.push({ end: end, start: start });\n  }\n  return ranges;\n}\n\n/**\n * @description Parse \"Range\" header `text` relative to the given file `size`.\n * @param {number} size - Size\n * @param {string} header - Header string\n * @param {Options=} options - Options\n * @returns {Ranges|Result}\n * @throws {TypeError}\n */\nexport function parseRange(size: number, header: string, options?: Options): Ranges | Result {\n  let throwError = true;\n  if (options && \"throwError\" in options && options.throwError === false) {\n    throwError = false;\n  }\n  if (!Number.isInteger(size)) {\n    if (throwError) {\n      throw new TypeError(`Argument 'size' must be an integer.`);\n    } else {\n      return ERROR_INVALID_ARGUMENT;\n    }\n  }\n  if (typeof header !== \"string\") {\n    if (throwError) {\n      throw new TypeError(`Argument 'header' must be a string.`);\n    } else {\n      return ERROR_INVALID_ARGUMENT;\n    }\n  }\n  const indexOfEqualSign = header.indexOf(\"=\");\n  if (indexOfEqualSign === -1) {\n    return ERROR_STRING_IS_NOT_HEADER;\n  }\n  const csv = header.slice(indexOfEqualSign + 1).split(\",\");\n  const ranges = csvToRanges(csv, size);\n  if (ranges.length < 1) {\n    return ERROR_UNSATISFIABLE_RESULT;\n  }\n  ranges.type = header.slice(0, indexOfEqualSign);\n  return options && options.combine ? combineRanges(ranges) : ranges;\n}\n"],
  "mappings": "AAgCO,GAAM,GAA8C,GAE9C,EAA4C,GAE5C,EAAkD,GAO/D,WAAuB,EAAwB,CAC7C,GAAM,GAAU,EAAO,IAAI,GAAc,KAAK,GAC1C,EAAQ,EACZ,OAAS,GAAQ,EAAG,EAAQ,EAAQ,OAAQ,IAAS,CACnD,GAAM,GAAwB,EAAQ,GAChC,EAA0B,EAAQ,GACxC,AAAI,EAAM,MAAQ,EAAQ,IAAM,EAC9B,EAAQ,EAAE,GAAS,EACV,EAAM,IAAM,EAAQ,KAC7B,GAAQ,IAAM,EAAM,IACpB,EAAQ,MAAQ,KAAK,IAAI,EAAQ,MAAO,EAAM,QAGlD,EAAQ,OAAS,EAAQ,EACzB,GAAM,GAAW,CAAC,GAAG,GAAS,KAAK,GAAkB,IAAI,GACzD,SAAS,KAAO,EAAO,KAChB,EAST,WAAsB,EAA+B,EAA+B,CAClF,MAAO,CAAE,IAAK,EAAM,IAAK,QAAO,MAAO,EAAM,OAQ/C,WAAyB,EAA8B,CACrD,MAAO,CAAE,IAAK,EAAM,IAAK,MAAO,EAAM,OASxC,WAA0B,EAAuB,EAA8B,CAC7E,MAAO,GAAM,MAAQ,EAAK,MAS5B,WAA0B,EAAc,EAAqB,CAC3D,MAAO,GAAM,MAAQ,EAAK,MAGrB,mBAAqB,MAAa,CAAlC,aArGP,CAqGO,oBAIE,UAAO,GAKP,SAAwB,CAC7B,GAAM,GAAQ,MAAM,KAAK,MACzB,SAAM,KAAO,KAAK,KACX,IAIX,WAAqB,EAAe,EAAsB,CACxD,GAAM,GAAS,GAAI,GACnB,OAAW,KAAQ,GAAK,CACtB,GAAM,GAAQ,EAAK,MAAM,KACrB,EAAQ,OAAO,SAAS,EAAM,GAAI,IAClC,EAAM,OAAO,SAAS,EAAM,GAAI,IAUpC,AATA,AAAI,OAAO,MAAM,GACf,GAAQ,EAAO,EACf,EAAM,EAAO,GACJ,OAAO,MAAM,IACtB,GAAM,EAAO,GAEX,EAAM,EAAO,GACf,GAAM,EAAO,GAEX,SAAO,MAAM,IAAU,OAAO,MAAM,IAAQ,EAAQ,GAAO,EAAQ,IAGvE,EAAO,KAAK,CAAE,IAAK,EAAK,MAAO,IAEjC,MAAO,GAWF,WAAoB,EAAc,EAAgB,EAAoC,CAC3F,GAAI,GAAa,GAIjB,GAHI,GAAW,cAAgB,IAAW,EAAQ,aAAe,IAC/D,GAAa,IAEX,CAAC,OAAO,UAAU,GAAO,CAC3B,GAAI,EACF,KAAM,IAAI,WAAU,uCAEpB,MAAO,GAGX,GAAI,MAAO,IAAW,SAAU,CAC9B,GAAI,EACF,KAAM,IAAI,WAAU,uCAEpB,MAAO,GAGX,GAAM,GAAmB,EAAO,QAAQ,KACxC,GAAI,IAAqB,GACvB,MAAO,GAET,GAAM,GAAM,EAAO,MAAM,EAAmB,GAAG,MAAM,KAC/C,EAAS,EAAY,EAAK,GAChC,MAAI,GAAO,OAAS,EACX,EAET,GAAO,KAAO,EAAO,MAAM,EAAG,GACvB,GAAW,EAAQ,QAAU,EAAc,GAAU",
  "names": []
}
