{"version":3,"file":"index.js","sources":["../src/index.ts"],"sourcesContent":["import Negotiator from 'negotiator'\nimport { IncomingMessage as I, IncomingHttpHeaders } from 'node:http'\nimport mime from 'mime'\n\nconst extToMime = (type: string) => (type.indexOf('/') == -1 ? mime.getType(type) : type)\n\nconst validMime = (type: unknown): boolean => typeof type == 'string'\n\nexport class Accepts {\n  headers: IncomingHttpHeaders\n  negotiator: Negotiator\n  constructor(req: Pick<I, 'headers'>) {\n    this.headers = req.headers\n    this.negotiator = new Negotiator(req)\n  }\n  /**\n   * Check if the given `type(s)` is acceptable, returning the best match when true, otherwise `false`, in which case you should respond with 406 \"Not Acceptable\".\n   *\n   * The `type` value may be a single mime type string such as \"application/json\", the extension name such as \"json\" or an array `[\"json\", \"html\", \"text/plain\"]`. When a list or array is given the _best_ match, if any is returned. When no types are given as arguments, returns all types accepted by the client in the preference order.\n   */\n  types(types: string | string[], ...args: string[]): string[] | string | false {\n    let mimeTypes: string[] = []\n\n    // support flattened arguments\n    if (types && !Array.isArray(types)) {\n      mimeTypes = [types, ...args]\n    } else if (types) {\n      mimeTypes = [...types, ...args]\n    }\n\n    // no types, return all requested types\n    if (!mimeTypes || mimeTypes.length == 0) {\n      return this.negotiator.mediaTypes()\n    }\n\n    // no accept header, return first given type\n    if (!this.headers['accept']) {\n      return mimeTypes[0]\n    }\n\n    const mimes = mimeTypes.map(extToMime)\n    const accepts = this.negotiator.mediaTypes(mimes.filter(validMime) as string[])\n    const [first] = accepts\n\n    return first ? mimeTypes[mimes.indexOf(first)] : false\n  }\n  get type(): (types: string | string[], ...args: string[]) => string[] | string | false {\n    return this.types\n  }\n  /**\n   * Return accepted encodings or best fit based on `encodings`.\n   *\n   * Given `Accept-Encoding: gzip, deflate`\n   * an array sorted by quality is returned:\n   *\n   *     ['gzip', 'deflate']\n   */\n  encodings(encodings: string | string[], ...args: string[]): string | string[] | boolean {\n    let _encodings: string[] = encodings as string[]\n\n    // support flattened arguments\n    if (_encodings && !Array.isArray(_encodings)) {\n      _encodings = [_encodings, ...args]\n    }\n\n    // no encodings, return all requested encodings\n    if (!_encodings || _encodings.length == 0) {\n      return this.negotiator.encodings()\n    }\n\n    return this.negotiator.encodings(_encodings)[0] || false\n  }\n  get encoding(): (encodings: string | string[], ...args: string[]) => string | string[] | boolean {\n    return this.encodings\n  }\n  /**\n   * Return accepted charsets or best fit based on `charsets`.\n   *\n   * Given `Accept-Charset: utf-8, iso-8859-1;q=0.2, utf-7;q=0.5`\n   * an array sorted by quality is returned:\n   *\n   *     ['utf-8', 'utf-7', 'iso-8859-1']\n   */\n  charsets(charsets?: string | string[], ...args: string[]): string | string[] | boolean {\n    let _charsets: string[] = charsets as string[]\n\n    // support flattened arguments\n    if (_charsets && !Array.isArray(_charsets)) {\n      _charsets = [_charsets, ...args]\n    }\n\n    // no charsets, return all requested charsets\n    if (!_charsets || _charsets.length == 0) {\n      return this.negotiator.charsets()\n    }\n\n    return this.negotiator.charsets(_charsets)[0] || false\n  }\n  get charset(): (charsets: string | string[], ...args: string[]) => string | string[] | boolean {\n    return this.charsets\n  }\n  /**\n   * Return accepted languages or best fit based on `langs`.\n   *\n   * Given `Accept-Language: en;q=0.8, es, pt`\n   * an array sorted by quality is returned:\n   *\n   *     ['es', 'pt', 'en']\n   *\n   */\n  languages(languages: string | string[], ...args: string[]): string | string[] | boolean {\n    let _languages: string[] = languages as string[]\n\n    // support flattened arguments\n    if (_languages && !Array.isArray(_languages)) {\n      _languages = [_languages, ...args]\n    }\n\n    // no languages, return all requested languages\n    if (!_languages || _languages.length == 0) {\n      return this.negotiator.languages()\n    }\n\n    return this.negotiator.languages(_languages)[0] || false\n  }\n  get lang(): (languages: string | string[], ...args: string[]) => string | string[] | boolean {\n    return this.languages\n  }\n  get langs(): (languages: string | string[], ...args: string[]) => string | string[] | boolean {\n    return this.languages\n  }\n  get language(): (languages: string | string[], ...args: string[]) => string | string[] | boolean {\n    return this.languages\n  }\n}\n"],"names":[],"mappings":";;AAIA,MAAM,YAAY,CAAC,SAAkB,KAAK,QAAQ,GAAG,KAAK,KAAK,KAAK,QAAQ,IAAI,IAAI;AAEpF,MAAM,YAAY,CAAC,SAA2B,OAAO,QAAQ;AAEtD,MAAM,QAAQ;AAAA,EAGnB,YAAY,KAAyB;AACnC,SAAK,UAAU,IAAI;AACd,SAAA,aAAa,IAAI,WAAW,GAAG;AAAA,EACtC;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAMA,MAAM,UAA6B,MAA2C;AAC5E,QAAI,YAAsB,CAAA;AAG1B,QAAI,SAAS,CAAC,MAAM,QAAQ,KAAK,GAAG;AACtB,kBAAA,CAAC,OAAO,GAAG,IAAI;AAAA,eAClB,OAAO;AAChB,kBAAY,CAAC,GAAG,OAAO,GAAG,IAAI;AAAA,IAChC;AAGA,QAAI,CAAC,aAAa,UAAU,UAAU,GAAG;AAChC,aAAA,KAAK,WAAW;IACzB;AAGA,QAAI,CAAC,KAAK,QAAQ,QAAQ,GAAG;AAC3B,aAAO,UAAU,CAAC;AAAA,IACpB;AAEM,UAAA,QAAQ,UAAU,IAAI,SAAS;AACrC,UAAM,UAAU,KAAK,WAAW,WAAW,MAAM,OAAO,SAAS,CAAa;AACxE,UAAA,CAAC,KAAK,IAAI;AAEhB,WAAO,QAAQ,UAAU,MAAM,QAAQ,KAAK,CAAC,IAAI;AAAA,EACnD;AAAA,EACA,IAAI,OAAmF;AACrF,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,UAAU,cAAiC,MAA6C;AACtF,QAAI,aAAuB;AAG3B,QAAI,cAAc,CAAC,MAAM,QAAQ,UAAU,GAAG;AAC/B,mBAAA,CAAC,YAAY,GAAG,IAAI;AAAA,IACnC;AAGA,QAAI,CAAC,cAAc,WAAW,UAAU,GAAG;AAClC,aAAA,KAAK,WAAW;IACzB;AAEA,WAAO,KAAK,WAAW,UAAU,UAAU,EAAE,CAAC,KAAK;AAAA,EACrD;AAAA,EACA,IAAI,WAA6F;AAC/F,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EASA,SAAS,aAAiC,MAA6C;AACrF,QAAI,YAAsB;AAG1B,QAAI,aAAa,CAAC,MAAM,QAAQ,SAAS,GAAG;AAC9B,kBAAA,CAAC,WAAW,GAAG,IAAI;AAAA,IACjC;AAGA,QAAI,CAAC,aAAa,UAAU,UAAU,GAAG;AAChC,aAAA,KAAK,WAAW;IACzB;AAEA,WAAO,KAAK,WAAW,SAAS,SAAS,EAAE,CAAC,KAAK;AAAA,EACnD;AAAA,EACA,IAAI,UAA2F;AAC7F,WAAO,KAAK;AAAA,EACd;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,EAUA,UAAU,cAAiC,MAA6C;AACtF,QAAI,aAAuB;AAG3B,QAAI,cAAc,CAAC,MAAM,QAAQ,UAAU,GAAG;AAC/B,mBAAA,CAAC,YAAY,GAAG,IAAI;AAAA,IACnC;AAGA,QAAI,CAAC,cAAc,WAAW,UAAU,GAAG;AAClC,aAAA,KAAK,WAAW;IACzB;AAEA,WAAO,KAAK,WAAW,UAAU,UAAU,EAAE,CAAC,KAAK;AAAA,EACrD;AAAA,EACA,IAAI,OAAyF;AAC3F,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,QAA0F;AAC5F,WAAO,KAAK;AAAA,EACd;AAAA,EACA,IAAI,WAA6F;AAC/F,WAAO,KAAK;AAAA,EACd;AACF;"}